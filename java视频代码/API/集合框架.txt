集合类的由来：
    对象用于封装特有数据，对象多了需要存储，如果对象的个数不确定
    就使用集合容器进行存储

集合特点：
    1.用于存储对象的容器
    2.集合的长度是可变的
    3.集合中不可以存储基本数据类型

集合容器因为内部的数据结构不同有多种具体容器
不断的向上抽取，就形成了集合框架

框架的顶层Collection接口：
Collection的常见方法：
1.添加
    boolean add(Object obj);返回boolean是返回添加成功与否
    boolean addAll(Collection coll);
2.删除
    boolean remove(Object obj);
    boolean removeAll(Collection coll);
    void clear();
3.判断
    boolean contains(Object obj);
    boolean contains(Collection coll);
    boolean ifEmpty();判断集合中是否有元素
4.获取
    int size();返回此 collection 中的元素数
    Iterator iterator();取出元素的方式，迭代器
    该对象必须依赖具体容器，因为每一个容器的数据结构都不同
    所以该迭代器对象是在容器中进行内部实现的
    对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可
    也就是iterator方法
5.其他
    boolean retainAll(Collection coll);仅保留此 collection 中那些也包含在指定 collection 的元素,取交集
    Object[] toArray();将集合转成数组

--------------------------------------------------------------
Collection
    |--List:有序（存入和取出的顺序一致），元素都有索引（角标），元素可以重复
    |--Set:元素不能重复，无序

List特有的常见方法：有一个共性特点就是可以操作角标
1.添加
    void add(int index,element);
    void add(int index,Collection);
2.删除
    Object remove(index);
3.修改
    Object set(index,element);
4.获取
    Object get(index);
    int indexOf(Object);
    int lastIndexOf(Object);
    List subList(from,to);含头不含尾
list集合是可以完成对元素的增删改查

List:
    |--Vector:内部是数组数据结构。是同步的。增删查询都很慢！
    |--ArrayList:内部是数组数据结构，不同步，替代了vector 查询的速度快，增删慢，因为牵一发动全身
    |--LinkedList:内部链表数据结构，是不同步的  增删元素的速度很快 有编号但是要从头一个挨一个的找

LinkedList:
    addFirst();
    addLast();
    jdk1.6
    offerFirst();
    offerLast();

    getFirst();//获取但不移除，如果链表为空，抛出NoSuchElementException
    getLast();
    jdk1.6
    peekFirst();//获取但不移除，如果链表为空，返回null
    peekLast();

    removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException
    removeLast();
    jdk1.6
    pollFirst();//获取并移除，如果链表为空，返回null
    pollLast();

Set:元素不可以重复，是无序
    Set接口中的方法和Collection一致
    |--HashSet：内部数据结构是哈希表，是不同步的

    |--TreeSet：